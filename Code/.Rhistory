geom_boxplot(width= .10, outlier.shape = NA)+
theme(legend.position="none")+
ggtitle("reaction times with outliers")
p1
print('some summary info')
summary(dataBig_out$rt)
#outlier removal method 2
upper_bound <- quantile (dataBig_out$rt, 0.9985)
print('upper 99.85% bound')
upper_bound
defaultW<-getOption("warn")
options(warn=-1)# this disables warning messages
dataBig_out <- subset(dataBig_out, rt < 30)
d<-melt(data.frame(rt=c(dataBig_out$rt)))
p3 <- ggplot(d, aes(x = variable, y = value, fill=variable))+
geom_flat_violin(position = position_nudge(x = .2, y = 0),adjust =2)+
geom_point(position=position_jitter(width=.15), size=0.25)+
ylab('rt')+xlab('amount')+coord_flip()+theme_cowplot()+
geom_boxplot(width= .10, outlier.shape = NA)+
theme(legend.position="none")+
guides(fill=FALSE)+
ggtitle("reaction times < 16 sec")
p3
options(warn=defaultW)#put warnings back on
print('some summary info')
summary(dataBig_out$rt)
#outlier removal method 2
out<-boxplot.stats(dataBig_out$rt)$out#outliers
out_ind<-which(dataBig_out$rt %in% c(out))#row numbers that contain outliers
boxplot(dataBig_out$rt, ylab='rt') #boxplot
mtext(paste('boxplot with outliers')) #boxplot with outliers
```
## Stimuli
These were images that were either negative, positive or neutral.
22 matched images (e.g. in TestMoment 1 image of needle in arm, in TestMoment 2 needle in leg. or image puppy and image of another puppy)
participants could indicate how the images scored for them on valence and arousal
these already have the rt data filtered under 16 sec (outliers removed)
we look at how people answer on the stimuli: can we categorize the stimuli in valence and arousal? Are there weird answers?
```{r echo=FALSE}
# unique<-sort(unique(dataBig$Stimulus), decreasing=FALSE) #find all the stimuli
# we maken een density plotvoor zowel valence als arousal voor elke stimulus (2x22)
ui<- fluidPage(
radioButtons("stimulus", label="Choose a Stimulus:",
choices= c('1440', '1463', '1610', '1710', '1722', '1750', '2057', '2070', '2160', '2165', '2340', '2360', '2800', '3261', '4180', '4290', '4490', '4531',  '4550', '4561', '4658', '5030', '5600', '5800', '5982', '6312', '6313', '7182', '7211', '7224', '7238', '7380', '7480', '7481', '9220', '9300', '9320', '9584', '9592', '9594', '9600', '9911', '9920', '9921'), inline=TRUE,
selected='1440'),
tabsetPanel(type = "tab",
tabPanel("densityplot", plotOutput("densityplot")),
tabPanel("IAPs_Image", plotOutput("IAPs_Image"))
)
)
server <- function (input, output){
#we make a density plot of valence/arousal per stimulus.
output$densityplot<- renderPlot({
d<-melt(data.frame(valence=c(dataBig2$Valence[dataBig2$Stimulus==input$stimulus]),arousal=c(dataBig2$Arousal[dataBig2$Stimulus==input$stimulus])))
d2<-data.frame(valence=c(dataBig2$Valence[dataBig2$Stimulus==input$stimulus]), ID=c(dataBig2$newid[dataBig2$Stimulus==input$stimulus]))
min<-d2$ID[which(d2$valence==min(d2$valence))]#ids of min valence
max<-d2$ID[which(d2$valence==max(d2$valence))]#ids of max valence
if (length(min)<length(max)){text=min } else {text=max}
pirateplot(
formula=value~variable,
data=d,
main= input$stimulus,
xlab= str_glue('outlier: {text}'))
}, height=600)
output$IAPs_Image <- renderImage({
list(src=str_glue("Z:/shares/ghep_lab/ImageDatabases/IAPS/{input$stimulus}.jpg"),
filetype="image/jpeg",
width=400,
height=300)
})
}
shinyApp(ui=ui, server=server, options= list(height=800))
```
#### outliers newid's:
25: VI: times a negative reaction to nakedness/sex: 4180, 4290, 4490, 4550, 4561,4658
75: IV: neg reactie nakedness and sex (4531, 4490, 4180, 4658)
145: II, neg reaction nakedness (4290, 4561)
284: III: neg reactie baby (2057, 2070, 2165)
47: II: neg reaction to clouds (5982) and positive to a needle in an arm (9594)
89: II: pos reactie op trippy schilderijen (7182, 7238)
169: II: pos reactie op vrouw gered dr brandweer (9921)
194: II: neg reactie ijsbergen (5600) en pasta (194)
1: II: antwoord altijd 0 of 100, ook op saaie kast (7224), schilderij (7238)
one-time outliers:
10  27  30  31  40  74  97 100 119 121 128 134 136 167 168 206 221
233 240 244 251 252 257 259 262 293 315 334 351 365 374 376
'medium'= 40-60
|  |  |
|:----|:----------------------|
|  **high valence, high arousal:** | 4658, 4561, 4658  |
| **high valence, low arousal:** |  2360, 5030, 5600, 5800, 5982, 5030, 5800, 5982 |
| **high valence, medium arousal:** | 1440, 1463, 1610, 1710, 1722, 1750, 2057, 2070, 2160, 2165, 2340 7480, 7481, 5600, 7480, 7481 |
| **low valence, high arousal:** | 2800, 3261, 6312, 6313, 7182, 7380, 6312, 6313, 7380, 9600, 9911, 9920, 9921 |
| **low valence, low arousal:** |  9220 |
| **low valence, medium arousal:** | 9300, 9320, 9584, 9592, 9594 |
| **medium valence, high arousal:** | 7182 |
| **medium valence, low arousal:** |  7224, 7224 |
| **medium valence, medium arousal:** |  7211, 7238, 4550, 7211, 7238 |
when Medium, arousal tends to be normally distributed
However: we often find 2 gauss curves on top of each other
same for valence: more of a gaussian curve when middle, more of a cup when towards the extreme.
### mean reactions over all stimuli
plot mean reaction per participant over all stimuli:
-mean valence
-mean arousal
-standard deviation
### Statistics
- plot means valence & arousal between groups (PMS, noPMS) on stimuli
- plot means testmoment x PMS
- statistical analysis: sign differences?
```{r echo=FALSE}
ui<- fluidPage(
radioButtons("formula_choice", label="Choose a Formula:",
choices= c('Valence~PMSScoreNew', 'Arousal~PMSScoreNew', 'Valence~PMSScoreNew * TestMoment', 'Arousal ~ PMSScoreNew * TestMoment'), inline=TRUE,
selected='Valence~PMSScoreNew'),
tabsetPanel(type = "tab",
tabPanel("pirateplot", plotOutput("pirateplot")),
tabPanel('plotmeans', plotOutput('plotmeans')),
tabPanel('splitviolin', plotOutput('splitviolin')),
tabPanel('int_means', plotOutput('int_means')),
tabPanel("AIC table", tableOutput("table")),
tabPanel("Anova", verbatimTextOutput("Anova")),
tabPanel("emmeans",verbatimTextOutput("emmeans"))
)
)
server <- function (input, output){
p_pms <-reactive({
p<-(p()[[3]][1]) # this gets the p-value of the first row, for PMS
star=c()
if (p> 0.05) {star=''
}else if (p<0.0005){star='***'
}else if (p<0.005){star='**'
}else if (p<0.05) {star='*'}
star
})
#for emmeans: em[[2]][1] is the p-value for first row
#we make a density plot of valence/arousal per stimulus.
output$pirateplot<- renderPlot({
pirateplot(
formula= input$formula_choice,
data=dataBig2,
theme= 1,
pal= "info",
main= input$formula_choice,
bean.f.o = .6, # Bean fill
point.o = .05,  # Points
inf.f.o = .7,  # Inference fill
inf.b.o = .8,  # Inference border
avg.line.o = 1,  # Average line
bar.f.o = .5, # Bar
inf.f.col = "white",  # Inf fill col
inf.b.col = "black",  # Inf border col
avg.line.col = "black",  # avg line col
bar.f.col = gray(.8),  # bar filling color
point.pch = 21,
point.bg = "white",
point.col = "black",
point.cex = .7,
xlab="",
)
}, height=600)
output$plotmeans <-renderPlot({
if (grepl('Arousal', input$formula_choice) &grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew', 'Moment'))
p3 <- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMSScoreNew))+
geom_flat_violin (aes(fill=PMSScoreNew), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
geom_boxplot(aes(x=Moment, y=Arousal, fill=PMSScoreNew), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Arousal, group=PMSScoreNew, colour=PMSScoreNew), size=1.5)+
geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Arousal, group = PMSScoreNew, fill= PMSScoreNew), shape = 21, size=6)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
annotate('text', x=1, y=105, label='*', size=8)+
annotate('text', x=2, y=105, label='*', size=8)+
geom_segment(aes(x = 0.97, y = 103, xend = 1.03, yend = 103), size= 2)+
geom_segment(aes(x = 1.97, y = 103, xend = 2.03, yend = 103), size= 2)+
ggtitle('Arousal ~ PMSScoreNew * TestMoment')
p3
}else if (grepl('Valence', input$formula_choice) & grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew', 'Moment'))
p3 <- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMSScoreNew))+
geom_flat_violin (aes(fill=PMSScoreNew), position= position_nudge(x=.1, y=0), adjust=1.5, alpha= .5, colour=NA)+
geom_boxplot(aes(x=Moment, y=Valence, fill=PMSScoreNew), outlier.shape=NA, alpha=.5, width=.1, colour='black')+
geom_line(data=dmean, aes(x= as.numeric(Moment)+.1, y=Valence, group=PMSScoreNew, colour=PMSScoreNew), size=1.5)+
geom_point(data = dmean, aes(x = as.numeric(Moment)+.1, y = Valence, group = PMSScoreNew, fill=PMSScoreNew), shape = 21, size=6)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Valence~PMSScoreNew * TestMoment')
p3
}
else if (grepl('Arousal', input$formula_choice) & !grepl('TestMoment', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew'))
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Arousal)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Arousal, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew)+.2, y = Arousal, fill=PMSScoreNew), shape = 21, size=6)+
geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Arousal), size=1, colour='black')+
geom_segment(aes(x = 1.2, y = 103, xend = 2.2, yend = 103), size= 1.7)+
# annotate('text', x=1.6, y=105, label=sprintf("\n%s\n", p_pms()), size=10)+
annotate('text', x=1.6, y=105, label='*', size=10)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Arousal~PMSScoreNew')
# coord_flip()
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Arousal)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust = 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Arousal, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew), y = Arousal, fill=PMSScoreNew), shape = 21, size=6)+
# geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Arousal), size=1, colour='black')+
geom_segment(aes(x = 1, y = 103, xend = 2, yend = 103), size= 1.7)+
# annotate('text', x=1.6, y=105, label=sprintf("\n%s\n", p_pms()), size=10)+
annotate('text', x=1.6, y=105, label='*', size=10)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Arousal~PMSScoreNew')
# coord_flip()
p1
}else {
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew'))
p1 <- ggplot(dataBig2, aes(x = PMSScoreNew, y = Valence)) +
geom_flat_violin(aes(fill=PMSScoreNew),position = position_nudge(x =.2, y = -1), adjust= 1.5, alpha = .5, colour = NA)+
geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
geom_boxplot(aes(x = PMSScoreNew, y = Valence, fill = PMSScoreNew),outlier.shape= NA, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew)+.2, y = Valence, fill=PMSScoreNew), shape = 21, size=6)+
geom_line(data=dmean, aes(x=as.numeric(PMSScoreNew)+.2, y=Valence), size=1, colour='black')+
# annotate('text', x=1.6, y=70, label=sprintf("\n%s\n", p_pms()), size=8)+
ggtitle('Valence~PMSScoreNew')
# coord_flip()
p1
#
# p<- ggplot(dataBig2, aes(x=PMSScoreNew, y=Valence, fill=PMSScoreNew))+
#     geom_split_violin(adjust=1.5,alpha=.5, colour=NA )+
#   geom_point(aes(colour=PMSScoreNew),position=position_jitter(width=.15), size=.25)+
#   geom_boxplot(aes(x = PMSScoreNew, y = Valence, fill = PMSScoreNew),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
#   geom_point(data = dmean, aes(x = as.numeric(PMSScoreNew), y = Valence, group = PMSScoreNew, fill = PMSScoreNew), position=position_dodge(0.2), shape = 21, size=4)+
#   ggtitle('Valence ~ PMS')
# p
#
#
#
}
}, height=600)
output$splitviolin <-renderPlot({
if (grepl('Arousal', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('PMSScoreNew', 'Moment'))
p<- ggplot(dataBig2, aes(x=Moment, y=Arousal, fill=PMSScoreNew))+
geom_split_violin(adjust =1.5, alpha=.5, colour= NA)+
geom_boxplot(aes(x = Moment, y = Arousal, fill = PMSScoreNew), position= position_dodge(0.2),outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(Moment), y = Arousal, group = PMSScoreNew, fill = PMSScoreNew), position= position_dodge(0.2), shape = 21, size=4)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
annotate('text', x=1, y=105, label='*', size=8)+
annotate('text', x=2, y=105, label='*', size=8)+
geom_segment(aes(x = 0.955, y = 103, xend = 1.055, yend = 103), size= 2)+
geom_segment(aes(x = 1.955, y = 103, xend = 2.055, yend = 103), size= 2)+
ggtitle('Arousal ~ PMS * TestMoment')
p
} else if (grepl('Valence', input$formula_choice)){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('PMSScoreNew', 'Moment'))
p<- ggplot(dataBig2, aes(x=Moment, y=Valence, fill=PMSScoreNew))+
geom_split_violin(adjust=1.5,alpha=.5, colour=NA)+
geom_boxplot(aes(x = Moment, y = Valence, fill = PMSScoreNew), position= position_dodge(0.2) ,outlier.shape= NA, alpha = .5, width = .1, colour = "black")+
geom_point(data = dmean, aes(x = as.numeric(Moment), y = Valence, group = PMSScoreNew, fill = PMSScoreNew), position=position_dodge(0.2), shape = 21, size=4)+
scale_x_discrete(labels=c('1'='control', '2'='premenstrual'))+
ggtitle('Valence ~ PMS * TestMoment')
p
}
}, height=600)
output$int_means <- renderPlot({
if ((grepl('Valence', input$formula_choice))){
dmean<-summarySE(dataBig2, measurevar="Valence", groupvars=c('TestMoment', 'PMSScoreNew'))# this function gives sd, se mean and default 95% C.I.
p<-ggplot(dmean, aes(x=TestMoment, y=Valence, colour=PMSScoreNew, group=PMSScoreNew)) +
geom_errorbar(aes(ymin=Valence-standard_error(Valence), ymax=Valence+standard_error(Valence), width=.1))+
geom_line() +
geom_point(size=3)
p} else {
dmean<-summarySE(dataBig2, measurevar="Arousal", groupvars=c('TestMoment', 'PMSScoreNew'))# this function gives sd, se mean and default 95% C.I.
p<-ggplot(dmean, aes(x=TestMoment, y=Arousal, colour=PMSScoreNew, group=PMSScoreNew)) +
geom_errorbar(aes(ymin=Arousal-standard_error(Arousal), ymax=Arousal+standard_error(Arousal), width=.1))+
geom_line() +
geom_point(size=3)
p}
})
models <- reactive({ # we need to create this within a reactive context to be able to access the formula_choice
m <- c()
# Formula <- 'DASS_Stress ~ PMSScoreNew * TestMoment + (1|Subject)'
Formula <- paste0(input$formula_choice, '+ (1|Subject)')
tryCatch(
{ d0.1 <- lmer(Formula,data=dataBig2); # if this formula works
m <- c(m, d1=d0.1)}, #we add this
error=function(e){})
tryCatch(
{ d0.2 <- glmer(Formula,data=dataBig2, family = gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d1=d0.2)},
error=function(e){})
tryCatch(
{ d0.3 <- glmer(Formula,data=dataBig2, family = gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d3=d0.3)},
error=function(e){})
tryCatch(
{ d0.4 <- glmer(Formula,data=dataBig2, family = Gamma(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d4=d0.4)},
error=function(e){})
tryCatch(
{ d0.5 <- glmer(Formula,data=dataBig2, family = Gamma(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d5=d0.5) },
error=function(e){})
tryCatch(
{ d0.6 <- glmer(Formula,data=dataBig2, family = Gamma(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d6=d0.6) },
error=function(e){})
tryCatch(
{ d0.7 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "identity"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
models <- c(models, d7=d0.7) },
error=function(e){})
tryCatch(
{ d0.8 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "inverse"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d8=d0.8) },
error=function(e){})
tryCatch(
{ d0.9 <- glmer(Formula,data=dataBig2, family = inverse.gaussian(link = "log"),glmerControl(optimizer= "bobyqa", optCtrl = list(maxfun = 100000)),nAGQ=nAGQ);
m <- c(m, d9=d0.9) },
error=function(e){})
m
})
output$table <-renderTable({
modelNames<-c()
tabel<-c()
for (i in 1:length(models())){
modelNames<-c(modelNames, names(models()[i]))
AIC<-AIC(models()[[i]])
tabel <- c (tabel, round(AIC))}
chosenModel = modelNames[which(tabel == min(tabel))]
tabel <- data.frame(Models=c('chosen  Model:', modelNames), AIC= c(chosenModel, tabel))
tabel
})
p<-reactive({
tabel<-c()
for (i in 1:length(models())){
AIC<- AIC(models()[[i]])
tabel <- c(tabel,round(AIC))}
chosenModel<-models()[which(tabel == min(tabel))]
Anova_1 <- Anova(chosenModel[[1]])
cat(sprintf("\nAnova\n"))
Anova_1
#            tabel<-c()
# for (i in 1:length(m)){
#     AIC<- AIC(m[[i]])
#     tabel <- c(tabel,round(AIC))}
# chosenModel<-m[which(tabel == min(tabel))]
#    Anova_1 <- Anova(chosenModel[[1]])
#    cat(sprintf("\nAnova\n"))
#    an<-Anova_1
})
output$Anova <- renderPrint({
p()
})
em <- reactive({
tabel<-c()
for (i in 1:length(models())){
AIC<- AIC(models()[[i]])
tabel <- c(tabel,round(AIC))}
chosenModel<-models()[which(tabel == min(tabel))]
cat(sprintf("\nemmeans of formula: %s\n", input$formula_choice))
if ((grepl("TestMoment", input$formula_choice)==FALSE)){
emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
}else{
emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
}
# tabel <- c()
#     for (i in 1:length(m)){
#   AIC<- AIC(m[[i]])
#   tabel <- c(tabel,round(AIC))}
# chosenModel<-m[which(tabel == min(tabel))]
# cat(sprintf("\nemmeans of formula: %s\n", Formula))
# if ((grepl("TestMoment", Formula)==FALSE)){
#  em<- emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew, adjust ="fdr", type="response")
# }else{
#   em<-  emmeans(chosenModel[[1]], pairwise ~ PMSScoreNew*TestMoment, adjust ="fdr", type="response")
# }
#
})
output$emmeans <- renderPrint({
em()
})
}
shinyApp(ui=ui, server=server, options= list(height=800))
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
library(yarrr)
library(lme4)
library(emmeans)
library(pander)
library(reshape)
library(lme4)
library(lmerTest)
library(pander)
library(ggpubr)
library(car)
library(arrow)
library(tibble)
nAGQ = 0 # Set to 1 for eventual analysis
subblock = 1 # 0 to do only control vs stress, 1 for subblocks
plotPrefix = "Plots/"
# Set and Get directories
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #Set WD to script location
# Load the csv file
if (subblock == 1){
data <-
as.data.frame(read_parquet("user_data_per_subblock.parquet"))
} else if (subblock == 0){
data <-
as.data.frame(read_parquet("user_data_per_block.parquet"))
}
View(data)
#############################
#                           #
##  PreProcessing PMS data ##
#############################
rm(list = ls()) # Clear environment
cat("\014") # Clear console
dev.off() # Clear plot window
########################## Declare workspace and load data ###########################
library(dplyr)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))# Set working directory to current directory
dataDir = "Z:/shares/ghepmk_data/2020_Kappen_PMS//"
# dateDir = "24082021//"
dateDir = "06102021//"
DataFrame <- as.data.frame(read.csv(file = paste0(dataDir, dateDir,"results-survey987313.csv"), head = TRUE, sep=",",  stringsAsFactors=FALSE))
DataFrame <- select(DataFrame, -c(lastpage, startlanguage, startdate, datestamp, IFC1, IFC2, IFC3, IFC4, IFC5, IFC6, auto1.SQ001., AgeValidation.SQ001., AgeValidation.SQ002., interviewtime, groupTime17, IFC1Time, IFC2Time, IFC3Time, IFC4Time, IFC5Time, IFC6Time, auto1Time, groupTime13, GenderTime, AgeTime, MenstruationTime, FirstMenstrualTime, RegularMentrualTime, MenopauseTime, PregnantTime, PostPregnantTime, ContraceptiveTime, DutchTime, HormonesTime, MentalTime, LaptopTime, MenstrualToelichtTime, CurrentMensesTime, MenstrualStartTime, MenstrualEndTime, MenstrualEndExpectedTime, MenstrualDurationTime, AgeValidationTime, EMailTime, groupTime16, SymptomsTime, DisturbanceTime, SymptomsPRETime, groupTime14, RRSTime, groupTime15, DASS21Time )) #Remove columns with irrelevant data
isala = DataFrame$Isala[DataFrame$Isala != ""]
### Clean data --> remove all rows without submitdate, since that means they didnt complete the screening
DataFrame <- DataFrame[!(is.na(DataFrame$submitdate) | DataFrame$submitdate==""), ]
substrRight <- function(x, n){ # A function that takes the last n characters of a string
substr(x, nchar(x)-n+1, nchar(x))}
DataFrame <- DataFrame[-c(which(DataFrame$ï..id == 2684)), ] # remove this one participant - not included because slipped through
DataFrameClean <- data.frame()
DataFrameClean <- select(DataFrame, c(ï..id, Age, FirstMenstrual, MenstrualStart, MenstrualEnd, MenstrualEndExpected, MenstrualDuration, Isala))
### Get total score per questionnaire
#Symptoms.PST 1-14
#Disturbance.PST A-E? 1-5
#RRS.R 1-22
#DASS21.DAS 1-21
################ Linking Excel file to assess A-B/B-A distribution #################
# ExcelPMS <- as.data.frame(read.csv(file = paste0(dataDir, dateDir,"Participant-Excel.csv"), head = TRUE, sep=";",  stringsAsFactors=FALSE))
ExcelPMS <- as.data.frame(read.csv(file = paste0(dataDir, dateDir,"Participant-Excel.csv"), head = TRUE, sep=",",  stringsAsFactors=FALSE))
library(tidyr)
ExcelPMS <- ExcelPMS %>% mutate_all(~ replace_na(.x, "")) # Replace all NA's with empty lines. This makes the code make better sense
library(dplyr)
# Add a column with the actual testing moments so we can verify whether they did it on time
ExcelPMS$TrueFollicular[ExcelPMS$Test.gemist == "TRUE"] = ExcelPMS$Nieuwe.folliculaire.fase[ExcelPMS$Test.gemist == "TRUE"]
ExcelPMS$TrueFollicular[ExcelPMS$Test.gemist == ""] = ExcelPMS$folliculaire.fase[ExcelPMS$Test.gemist == ""]
ExcelPMS$TrueLuteal[ExcelPMS$Test.gemist == "TRUE"] = ExcelPMS$Nieuwe.luteale.fase[ExcelPMS$Test.gemist == "TRUE"]
ExcelPMS$TrueLuteal[ExcelPMS$Test.gemist == ""] = ExcelPMS$luteale.fase[ExcelPMS$Test.gemist == ""]
Randomisatie <- select(ExcelPMS, Entry.nummer, email, ï..Participantnummer, Randomisatie, Exclusie, TrueFollicular, TrueLuteal, duur.cyclus)
# Trim the email addresses because some have whitespace at the end
DataFrame$EMail <- trimws(DataFrame$EMail)
Randomisatie$email <- trimws(Randomisatie$email)
DataFrame$testVolgorde = ''
DataFrame$participantID = ''
for (i in 1:nrow(DataFrame)){ # Loop over all participant rows that filled out screening completely
# loc = which(Randomisatie$Entry.nummer == DataFrame$ï..id[i]) # Check for location of their entry number in the participant Excel file
loc = which(Randomisatie$email == DataFrame$EMail[i]) # Check for location of their entry number in the participant Excel file
if (length(loc) == 0) {
print(paste0("Something going on with participant ",toString(DataFrame$ï..id[i])," AKA entrynumber " ))
} else {
DataFrame$testVolgorde[i] = Randomisatie$Randomisatie[loc] # Use this location to grab their randomisation and participantNumber allocated
DataFrame$participantID[i] = Randomisatie$ï..Participantnummer[loc]
DataFrame$Exclusie[i] = Randomisatie$Exclusie[loc]
DataFrame$TrueFollicular[i] = Randomisatie$TrueFollicular[loc]
DataFrame$TrueLuteal[i] = Randomisatie$TrueLuteal[loc]
if (DataFrameClean$MenstrualDuration[i] != Randomisatie$duur.cyclus[loc]){ # If the durations of cycle don't match, this often means the participant didnt understand the question properly. So overwrite this with manual data entered after correspondance with participant
DataFrameClean$MenstrualDuration[i] = Randomisatie$duur.cyclus[loc]
}
}
}
# Add to Clean Dataframe
Order <- DataFrame$testVolgorde
participantNo <- DataFrame$participantID
Exclusie <- DataFrame$Exclusie
TrueFollicular <- DataFrame$TrueFollicular
TrueLuteal <- DataFrame$TrueLuteal
DataFrameClean <- cbind(DataFrameClean, participantNo, Order, Exclusie, TrueFollicular, TrueLuteal)
########################## Symptoms ###########################
SymptomsData <- DataFrame[ , grepl( "Symptoms.PST" , names( DataFrame ) ) ] # Make dataset with only Symtoms variables
SymptomsData <- cbind(SymptomsData, Symptoms.PST04=c(DataFrame$Symptoms.SPST04))
SymptomsData <- SymptomsData[,c(1,2,3,14,4,5,6,7,8,9,10,11,12,13)]
allSymptoms = 0
for(i in 1:nrow(DataFrame)) { # loop through participants
SymptomsScore <- 0
for(t in 1:ncol(SymptomsData)){ # loop through questions
temp = as.numeric(substrRight(unlist(SymptomsData[t])[i],1)) # Take value i (participant) from SymptomsDATA, unlist, then take last character and turn it into a number (double)
SymptomsScore <- SymptomsScore + temp
}
allSymptoms[i] <- SymptomsScore
}
# print(allSymptoms) # allSymptoms consists of all total Symptoms scores per participant
DataFrameClean <- cbind(DataFrameClean, allSymptoms)
########################## Disturbance ###########################
DisturbanceData <- DataFrame[ , grepl( "Disturbance.PST" , names( DataFrame ) ) ] # Make dataset with only Disturbance variables
allDisturbance = 0
for(i in 1:nrow(DataFrame)) { # loop through participants
DisturbanceScore <- 0
for(t in 1:ncol(DisturbanceData)){ # loop through questions
temp = as.numeric(substrRight(unlist(DisturbanceData[t])[i],1)) # Take value i (participant) from DisturbanceDATA, unlist, then take last character and turn it into a number (double)
DisturbanceScore <- DisturbanceScore + temp
}
allDisturbance[i] <- DisturbanceScore
}
# print(allDisturbance) # allDisturbance consists of all total Disturbance scores per participant
DataFrameClean <- cbind(DataFrameClean, allDisturbance)
########################## RRS ###########################
RRSData <- DataFrame[ , grepl( "RRS.R" , names( DataFrame ) ) ] # Make dataset with only RRS variables
allRRS = 0
View(RRSData)
